<?php
/*
+---------------------------------------------------------------------------
|
|   commander.class.php (php 4.x)
|
|   by Benjam Welker
|   http://www.iohelix.net
|   commander@iohelix.net
|
+---------------------------------------------------------------------------
|
|   > Power Game Class
|   > Date started: 2006-07-14
|
|  This class provides functions for testing and performing
|  all commands during the game.
|
+---------------------------------------------------------------------------
*/

// TODO: pre-comment all functions
// TODO: adjust functions for three player game (mercenary forces)


class commander
{
	var $error;        // any errors generated by the class
	var $command;      // the current command being parsed
	var $board;        // the board as an array (expanded)
	var $players;      // the players array (keys are colors, values are player_ids)
	var $commands;     // the array holding each players commands (keys are colors, values are command sets)
	var $conflicts;    // the sector conflicts array
	var $flagCaptures; // the flag captures array
	var $miniFlag;     // the mini flag captures array
	var $awards;       // for players who need to choose which color pieces are awarded to
	var $LAND;         // the $LAND adjacency array (includes/constants.inc.php)
	var $SEA;          // the $SEA adjacency array (includes/constants.inc.php)
	var $PIECE;        // the $PIECE data array (includes/constants.inc.php)
	var $SECTORS;      // the $SECTORS data array (includes/constants.inc.php)
	var $debug;        // the debug flag



	function commander($LAND, $SEA, $PIECE, $SECTORS)
	{
		$this->LAND    = $LAND;
		$this->SEA     = $SEA;
		$this->PIECE   = $PIECE;
		$this->SECTORS = $SECTORS;

		$this->debug = false; // set to true for permanent debugging
	}



	//*/
	//////////////////////////////////////////////////////////
	//
	//   Command Functions
	//
	//////////////////////////////////////////////////////////
	//*



	function setCommand($command, $color)
	{
		// clean the command
		$command = $this->cleanCommand($command);

		// get the command data
		$command = $this->getCommandData($command);

		// save the data to the command array
		$this->commands[$color][] = $command;
	}



	function setCommands($command_lists)
	{
		$this->clearCommands( );

		foreach ($command_lists as $color => $command_list)
		{
			foreach (explode(',', $command_list) as $command)
			{
				if ('' != $command)
				{
					$cmd_data = $this->getCommandData($command);
					$this->commands[$color][] = $cmd_data;
				} // end if empty command check
			} // end foreach command loop
		} // end foreach command list loop
	} // end setCommands



	function clearCommands( )
	{
		$this->commands = false;
	}



	function getCommands( )
	{
		return $this->commands;
	}



	function cleanCommand($command)
	{
		// remove anything that's not a letter, number, dash, or greater than sign
		$command = preg_replace('/[^->a-z0-9]/i', '', $command);

		// capitalize the command
		$command = strtoupper($command);

		// convert any entries of 'HQ' into just 'Q'
		// (it would be a bad command to otherwise have
		// H and Q next to each other like that)
		$command = str_replace('HQ', 'Q', $command);

		// make sure any sea lanes have two digits
		// if we match one digit
		if (0 < preg_match('/L\\d/i', $command))
		{
			// but not two
			if (0 == preg_match('/L\\d\\d/i', $command))
			{
				// add an empty space to the end so the regex will match everywhere
				$command .= ' ';

				// add the zero in there
				$command = preg_replace('/L(\\d\\D)/i', 'L0$1', $command);
			}
		}

		// trim any spaces we may have added
		return trim($command);
	}



	function getCommandData($command)
	{
		if ($this->debug) echo "<br/>getCommandData($command)<div style=\"border:2px solid black;margin: 0 5px 0 2em;\">";

		// clean the command and save it
		$command = $this->cleanCommand($command);
		$this->command = $command;
		if ($this->debug) call($this->command);

		// save the default data array values
		$data = array( );
		$data[0] = false;

		// check for a command
		if ('' == $this->command)
		{
			$this->error = 'No command given';
			$data['error'] = $this->error;
			if ($this->debug) { call($data); echo '</div>'; }
			return $data; // do not continue
		}

		// extract the command bits
		$command_array = explode('-', $this->command);
		if (3 == count($command_array))
		{
			list($piece, $from, $to) = $command_array;
		}
		else // the command is obviously bad
		{
			$this->error = 'There is a command format error';
			$data['error'] = $this->error;
			if ($this->debug) { call($data); echo '</div>'; }
			return $data; // do not continue
		}

		// search the 'piece' code for the color code
		if (0 == preg_match('/[YKRA]/i', $piece))
		{
			$this->error = 'No color code given';
			$data['error'] = $this->error;
			if ($this->debug) { call($data); echo '</div>'; }
			return $data; // do not continue
		}

		// search the 'to' code for the color code (if needed)
		if (false !== strpos($to, '>'))
		{
			if (0 == preg_match('/[YKRA]/i', $to))
			{
				$this->error = 'No color code given';
				$data['error'] = $this->error;
				if ($this->debug) { call($data); echo '</div>'; }
				return $data; // do not continue
			}
		}

		// clear any error
		$this->error = false;

		// run the tests and save each error separately
		$trade = $this->isTradePossible($piece, $to);
		$trade_error = $this->error;

		$move  = $this->isMovePossible($from, $to, $piece);
		$move_error  = $this->error;

		if (false != $trade)
		{
			if ($this->debug) call('TRADE PASSED');
			$data[0] = true;
			$data['type'] = 'trade';
			$data['sector'] = $from;
			$data['from'] = explode(',', $piece);
			$data['to'] = substr($to, 1); // remove the > symbol
		}
		else if (false != $move)
		{
			if ($this->debug) call('MOVE PASSED');
			$data[0] = true;
			$data['type'] = 'move';
			$data['piece'] = $piece;
			$data['from'] = $from;
			$data['to'] = $to;
		}
		else
		{
			if ($this->debug) call('TESTS FAILED');
			// save the proper error
			$this->error = ('This command is not a trade' == $trade_error) ? $move_error : $trade_error;
			$data['error'] = $this->error;
		}

		// return the data array
		if ($this->debug) { call($data); echo '</div>'; }
		return $data;
	} // end of getCommandData



	function validateCommand($data)
	{
		if ($this->debug) echo "<br/>validateCommand($data)<div style=\"border:3px double red;margin: 0 5px 0 2em;\">";

		// test if the command is valid
		if (false == $data[0])
		{
			$this->error = 'The command is not valid';
			if ($this->debug) { call($this->error); echo '</div>'; }
			return false;
		}

		// do the move
		if ('move' == $data['type'])
		{
			if ($this->debug) call('--MOVE--');

			// try to find the piece in the from sector
			$occupants = $this->board[$data['from']];
			if (false === $this->findPiece($data['piece'], $occupants))
			{
				$this->error = 'The piece was not found in the sector';
				if ($this->debug) { call($this->error); echo '</div>'; }
				return false;
			}

			// move the piece
			$this->movePiece($data['piece'], $data['from'], $data['to']);
			if ($this->debug) { call(true); echo '</div>'; }
			return true;
		} // end of move if

		// do the trade
		if ('trade' == $data['type'])
		{
			if ($this->debug) call('--TRADE--');

			// try to find the pieces in the sector
			// get the array of pieces in the sector
			$occupants = $this->board[$data['sector']]; // get the array data
			if ($this->debug) { call('occupants'); call($occupants); call( ); }

			// get the array of pieces in to be traded (already an array)
			$traders = $data['from'];
			if ($this->debug) { call('traders'); call($traders); call( ); }

			// check for Z
			$traders_string = implode(',', $traders); // convert to string for searching ease
			if (false !== strpos($traders_string, 'Z'))
			{
				// make sure Z is the only trade in 'piece' entered
				if (1 < count($traders))
				{
					$this->error = 'Other trade entered with Z shorthand';
					if ($this->debug) { call($this->error); echo '</div>'; }
					return false;
				}

				// we're only using the one 'piece' so use it exclusively
				$trader = $traders[0];

				// check the sector for enough pieces
				$total_points = 0;
				foreach ($occupants as $occupant)
				{
					if ($occupant['color'] == $trader['color'])
					{
						$total_points += $occupant['num'] * $this->PIECE[$occupant['type']]['power'];
					}
				} // end of occupants foreach loop

				if (100 > $total_points)
				{
					$this->error = 'At least 100 points must be traded in for a Megamissle';
					if ($this->debug) { call($this->error); echo '</div>'; }
					return false;
				}

				// create an array of items with the point value the key
				$power_array = array( );
				foreach ($occupants as $occupant)
				{
					// get the occupant data
					$occupant = $this->getPieceData($occupant);

					if ($occupant['color'] == $trader['color'])
					{
						$power_array[$this->PIECE[$occupant['type']]['power']] = array(
							$occupant['num'], $occupant['type']
						);
					}
				} // end of occupants foreach loop
				krsort($power_array); // reverse sort the array based on the power
				if ($this->debug) call($power_array);

				// select the proper items for the trade
				$difference = $total_points - 100;
				if ($this->debug) call($difference);
				foreach ($power_array as $power => $item)
				{
					// run through and remove the largest possible items from the trade array
					while ($power <= $difference)
					{
						// if we have enough of these pieces left
						if (0 < $power_array[$power][0])
						{
							--$power_array[$power][0]; // decrease the number of items used
							$difference -= $power; // decrease the power difference
						}
						else // we don't have any of this kind of piece remaining to remove
						{
							continue 2; // return to the foreach loop and skip to the next piece
						}
					} // end of while loop
				} // end of power_array foreach loop
				if ($this->debug) call($difference);
				if ($this->debug) call($power_array);

				// create the 'from' array for the trade from the edited power_array
				$col = $trader['color']; // get the color for the new array
				$from = array( );
				foreach ($power_array as $piece)
				{
					if (0 != $piece[0])
					{
						$num = (1 < $piece[0]) ? $piece[0] : '';
						$from[] = $num . $col . $piece[1];
					}
				}

				// make the trade
				$this->tradePieces($data['sector'], $from, $data['to']);
				if ($this->debug) { call(true); echo '</div>'; }
				return true;
			} // end of 'Z' if

			// parse through each and check them against each other
			foreach ($traders as $trader)
			{
				// get the trader data
				$trader = $this->getPieceData($trader);
				if ($this->debug) { call('trader'); call($trader); call( ); }

				$found = false; // init the found flag
				foreach ($occupants as $occupant)
				{
					if ($this->debug) { call( ); call('--occupant--'); call($occupant); call( );}
					// compare them
					if (($trader['color'] == $occupant['color']) && ($trader['type'] == $occupant['type']))
					{
						call($trader['num']);call($occupant['num']);
						// make sure we have enough of them
						if ($trader['num'] > $occupant['num'])
						{
							$this->error = 'Not enough pieces to trade';
							if ($this->debug) { call($this->error); echo '</div>'; }
							return false;
						}
						else // we have enough
						{
							// let the script know we found them
							$found = true;
						}
					}
				} // end occupant foreach loop

				// if we haven't found them yet
				if ( ! $found)
				{
					$this->error = 'The pieces were not found in the sector';
					if ($this->debug) { call($this->error); echo '</div>'; }
					return false;
				}
			} // end trader foreach loop
			call($data);

			// make the trade
			$this->tradePieces($data['sector'], $data['from'], $data['to']);
			if ($this->debug) { call(true); echo '</div>'; }
			return true;
		} // end 'trade' if
	} // end validateCommand



	function getMoveCount($from, $to, $method = 'LAND', $full = false)
	{
		if ($this->debug) echo "getMoveCount($from, $to, $method, $full)<div style=\"border:2px solid red;margin: 0 5px 0 2em;\">";

		// if we are moving to the same sector, the player is emphysema... just return 0
		if ($from == $to)
		{
			if ($this->debug) { call(0); echo '</div>'; }
			return 0;
		}

		// init the checked array
		// this array will hold the values for the squares already checked
		$checked = array( );

		// init the next array to start with the 'from' sector
		$next = array($from);

		if ('AIR' == $method)
		{
			$method = 'LAND'; // use the land adjacencies
		}

		// get the max number of moves, LAND = 5, SEA = 1
		$max = ('LAND' == $method) ? 5 : 1;

		// if we want to count the moves, ignore the method and just count them
		$max = (true === $full) ? 9 : $max; // the maximum moves to anywhere on the board is 8 (+1 just to be sure)
		if ($this->debug) call($max);

		// run through and check the sectors
		for ($count = 1; $count <= $max; ++$count)
		{
#     if ($this->debug) call($count . ' ---');

			// collect the sectors adjacent to the sectors in the $next array
			$all = array( ); // reset or init, whichever
			foreach ($next as $current)
			{
				// if we've checked this sector already, skip it
				if (in_array($current, $checked))
				{
					continue;
				}

				// test for missing sectors
				// this may happen when a tank tries to go in the water, etc.
				if ( ! isset($this->{$method}[$current]))
				{
					// no need for an error, it is generated by the isMovePossible function
					if ($this->debug) { call(false); echo '</div>'; }
					return false;
				}

				// convert the adjacency string to an array for easier handling
				$new = explode(',', $this->{$method}[$current]);
				$all = array_merge($all, $new);
				$all = array_unique($all);
			} // end foreach loop

			// check the whole thing for the 'to' sector
			if (in_array($to, $all))
			{
				// if we found it, return the move count
				if ($this->debug) { call($count); echo '</div>'; }
				return $count;
			}

			// if we didn't find it...
			// combine the previous $next values in with the $checked values
			$checked = array_merge($checked, $next);
			$checked = array_unique($checked); // so it doesn't get very big

			// save the new values for the next go around
			$next = $all;
		} // end for loop

		// if we get here, we went too far
		if ($this->debug) { call(false); echo '</div>'; }
		return false;
	} // end getMoveCount



	function isMovePossible($from, $to, $piece_code)
	{
		if ($this->debug) echo "isMovePossible($from, $to, $piece_code)<div style=\"border:2px solid blue;margin: 0 5px 0 2em;\">";

		// test the command for an exchange
		if (false !== strpos($to, '>'))
		{
			$this->error = 'This command is not a move';
			if ($this->debug) { call($this->error); echo '</div>'; }
			return false;
		}

		// remove the color code
		$piece_code = preg_replace('/[YKRA]/i' ,'', $piece_code);

		// test if the piece exists (weed out Power units here as well)
		if (( ! isset($this->PIECE[$piece_code])) || ('P' == $piece_code))
		{
			$this->error = 'No such movable piece exists';
			if ($this->debug) { call($this->error); echo '</div>'; }
			return false;
		}

		// if we are moving the megamissle, just do it
		if ('M' == $piece_code)
		{
			if ($this->debug) { call(true); echo '</div>'; }
			return true;
		}

		// save the piece array for easier handling
		$piece = $this->PIECE[$piece_code];

		// get the total number of moves
		$count = $this->getMoveCount($from, $to, $piece['method'], true);

		// test if it can even be done at all
		// this weeds out ships on land, tanks in the water, non-commands, etc.
		if (false === $count)
		{
			$this->error = 'There is a command format error';
			if ($this->debug) { call($this->error); echo '</div>'; }
			return false; // not possible
		}

		if (0 == $count)
		{
			$this->error = 'A move cannot be to the same sector';
			if ($this->debug) { call($this->error); echo '</div>'; }
			return false;
		}

		// test if the piece can make it that far
		if ($piece['max_sectors'] < $count)
		{
			$this->error = 'That piece cannot travel that far';
			if ($this->debug) { call($this->error); echo '</div>'; }
			return false;
		}

		// if we are on land
		if ('LAND' == $piece['method'])
		{
			// make sure we are not moving through an island
			// if the codes prefixes are different
			if (substr($from,0,1) != substr($to,0,1))
			{
				// make an island array for comparison
				$islands = array('N','S','E','W','X');

				// if it's not an island, it's no good
				if ( ! in_array($from, $islands) && ! in_array($to, $islands))
				{
					$this->error = 'Land based pieces must stop on an island';
					if ($this->debug) { call($this->error); echo '</div>'; }
					return false;
				}
			}
		}

		// if we made it here, it's all good
		if ($this->debug) { call(true); echo '</div>'; }
		return true;
	} // end of isMovePossible



	function isTradePossible($from, $to)
	{
		if ($this->debug) echo "isTradePossible($from, $to)<div style=\"border:2px solid green;margin: 0 5px 0 2em;\">";

		// test the command for an exchange
		if (false === strpos($to, '>'))
		{
			$this->error = 'This command is not a trade';
			if ($this->debug) { call($this->error); echo '</div>'; }
			return false;
		}

		// remove the color codes (we're only testing the possibility)
		$from = preg_replace('/[YKRA]/i' ,'', $from);
		$to   = preg_replace('/[YKRA]/i' ,'', $to);

		// get out the trade-to piece
		$to_piece = substr($to, 1, 1);

		// test for Mega trade
		if ('M' == $to_piece)
		{
			// test for Z code
			if ('Z' == $from)
			{
				// this will never fail
				// it may fail later, upon inspection of the sector
				// but not here
			}
			else // it's a multi-piece trade
			{
				// get the various piece codes out
				$pieces = explode(',', $from);

				// count the total points for all the pieces
				$total = 0;
				foreach($pieces as $piece)
				{
					$number = substr($from, 0, 1);
					$piece  = substr($from, 1, 1);

					$total += $number * $this->PIECE[$piece]['power'];
				}

				if (100 > $total)
				{
					$this->error = 'At least 100 points must be traded in for a Megamissle';
					if ($this->debug) { call($this->error); echo '</div>'; }
					return false;
				}
			}
		}
		else // its a normal piece trade
		{
			// test for multi-piece trades
			$pieces = explode(',', $from);
			if (1 < count($pieces))
			{
				$this->error = 'Only one type of piece can be traded per command';
				if ($this->debug) { call($this->error); echo '</div>'; }
				return false;
			}

			if ('Z' == $from)
			{
				$this->error = 'Z code is only valid for Megamissle trades';
				if ($this->debug) { call($this->error); echo '</div>'; }
				return false;
			}

			// we should only have one kind of piece
			// and can only swap one type of piece per command
			// so if the command is bad, it will fail here
			$number = substr($from, 0, 1);
			$piece  = substr($from, 1, 1);
			if ($this->debug) { call($number); call($piece); }

			// test the piece for possibility of trade
			if (( ! isset($this->PIECE[$piece])) || (false === $this->PIECE[$piece]['exchange']))
			{
				$this->error = 'These pieces cannot be traded';
				if ($this->debug) { call($this->error); echo '</div>'; }
				return false;
			}

			// test the piece for correct trade
			if (('P' != $piece) && ($this->PIECE[$piece]['exchange'] != $to_piece))
			{
				$this->error = 'Wrong type of piece traded';
				if ($this->debug) { call($this->error); echo '</div>'; }
				return false;
			}

			if (('P' != $piece) && (3 != $number))
			{
				$this->error = 'Wrong number of trade-in pieces';
				if ($this->debug) { call($this->error); echo '</div>'; }
				return false;
			}

			// run tests for power unit trades
			if ('P' == $piece)
			{
				$reqd = $this->PIECE[$to_piece]['power'];
				$have = $number;

				if ($have != $reqd)
				{
					$this->error = 'Wrong number of trade-in pieces';
					if ($this->debug) { call($this->error); echo '</div>'; }
					return false;
				}
			}
		}

		// if we make it here, it's all good
		if ($this->debug) { call(true); echo '</div>'; }
		return true;
	} // end of isTradePossible



	//*/
	//////////////////////////////////////////////////////////
	//
	//   Piece Functions
	//
	//////////////////////////////////////////////////////////
	//*



	function findPiece($piece, $sector_array)
	{
		// break apart the piece into its data components
		$piece = $this->getPieceData($piece);

		// if the sector is empty
		if ( ! is_array($sector_array))
		{
			return false;
		}

		// parse through the sector array and look at each piece
		foreach ($sector_array as $key => $piece_array)
		{
			// if it's the right type
			if (strtoupper($piece_array['type']) == strtoupper($piece['type']))
			{
				// if it's the right color
				if (strtoupper($piece_array['color']) == strtoupper($piece['color']))
				{
					// if there are some left
					if (0 < $piece_array['num'])
					{
						// return the array key
						return $key;
					} // end if any left
				} // end if right color
			} // end if right type
		} // end foreach sector loop

		// if we haven't found it yet, we won't find it
		return false;
	} // end findPiece



	function getPieceData($item) // array or single
	{
#   if ($this->debug) echo "<br />getPieceData($item)<div style=\"border:1px solid grey;margin: 0 5px 0 2em;\">";

		if ('' == $item)
		{
#     if ($this->debug) echo '</div>';
			return false;
		}

		if (is_array($item)) // recurse through an array of pieces
		{
			foreach ($item as $key => $thing)
			{
				$item[$key] = $this->getPieceData($thing);
			}

#     if ($this->debug) echo '</div>';
			return $item;
		}
		else
		{
			$piece = array( );

			// get the number of this type of piece
			$piece['num'] = (preg_match('/^\\d+/', $item, $match)) ? $match[0] : 1;
#     if ($this->debug) call($piece['num']);

			// get the color of this piece
			if (preg_match('/[YKRA]/i', $item, $match))
			{
				$piece['color'] = $match[0];
#       if ($this->debug) call($match);
			}
			else
			{
#       if ($this->debug) { call('NO COLOR FOUND'); echo '</div>'; }
				return false;
			}

			// get the type of this piece
			if (preg_match('/[IGTHFBDCPMV]/i', $item, $match))
			{
				$piece['type'] = $match[0];
#       if ($this->debug) call($match);
			}
			else
			{
#       if ($this->debug) { call('NO PIECE FOUND'); echo '</div>'; }
				return false;
			}

#     if ($this->debug) echo '</div>';
			return $piece;
		}
	} // end getPieceData



	function addColorCode($command, $color)
	{
		if ($this->debug) echo "<br/>addColorCode($command, $color)<div style=\"border:1px dashed red;margin: 0 5px 0 2em;\">";

		if ('' == $command || '' == $color)
		{
			if ($this->debug) echo '</div>';
			return false;
		}

		// clean the command
		$command = $this->cleanCommand($command);

		// get the bits of the command
		$command_array = explode('-', $command);
		if (3 == count($command_array))
		{
			list($piece, $from, $to) = $command_array;
		}
		else
		{
			$this->error = 'There is a command format error';
			if ($this->debug) { call($this->error); echo '</div>'; }
			return $command; // just give it back so that it stays in the command list for future edits
		}

		// break the piece code into the various pieces
		$pieces = explode(',', $piece);
#   if ($this->debug) call($pieces);

		$codes = array( );
		foreach ($pieces as $code)
		{
			// search for a color code
			if (0 == preg_match('/[YKRA]/i', $code))
			{
#       if ($this->debug) { call('-- REPLACING --'); call(preg_match('/(?=[IGTHFBDCPMZ])/i', $code)); }
				// place the color code before any piece codes
				$code = preg_replace('/(?=[IGTHFBDCPMZ])/i', $color, $code);
			}

			// save the new code to the array
			$codes[] = $code;
		}

		// test the command for a trade and colorize the to piece
		if (false !== strpos($to, '>'))
		{
			// search for a color code
			if (0 == preg_match('/[YKRA]/i', $to))
			{
#       if ($this->debug) { call('-- REPLACING --'); call(preg_match('/(?=[IGTHFBDCPMZ])/i', $code)); }
				// place the color code before any piece codes
				$to = preg_replace('/(?=[IGTHFBDCPMZ])/i', $color, $to);
			}
		}

		// recombine the new piece codes
		$piece = implode(',', $codes);

		// recombine the command
		$command = $piece . '-' . $from . '-' . $to;

		if ($this->debug) { call($command); echo '</div>'; }
		return $command;
	} // end addColorCode



	// TODO: edit for mercenary forces
	function isColorValid($data, $colors)
	{
		// turn the color list into a regex
		$color_regex = '/[' . str_replace(',', '', $colors) . ']/i';

		// now search the full color regex for the ones we have and remove them
		$other_colors = preg_replace($color_regex, '', 'YKRA');

		if ('move' == $data['type'])
		{
			// now search the piece for the 'other' colors
			if (preg_match("/[$other_colors]/i", $data['piece']))
			{
				$this->error = 'Not the correct piece color';
				return false;
			}
			else
			{
				return true;
			}
		}
		else if ('trade' == $data['type'])
		{
			// search through each of the from pieces given in the array
			foreach ($data['from'] as $from)
			{
				// now search the from piece for the 'other' colors
				if (preg_match("/[$other_colors]/i", $from))
				{
					$this->error = 'Not the correct piece color';
					return false;
				}
			}

			// now search the to piece for the 'other' colors
			if (preg_match("/[$other_colors]/i", $data['to']))
			{
				$this->error = 'Not the correct piece color';
				return false;
			}
			else
			{
				return true;
			}
		}
		else // i have no idea, just output false
		{
			return false;
		}
	} // end isColorValid



	function removePiece($piece_code, $sector, $unmoved = true)
	{
		if ($this->debug) echo "<br/>removePiece($piece_code, $sector, $unmoved)<div style=\"border:1px dotted blue;margin: 0 5px 0 2em;\">";

		if ($this->debug) call($this->board[$sector]);

		// find the piece we are looking for
		foreach ($this->board[$sector] as $key => $piece)
		{
			// if we found it
			if ($piece_code == $piece['color'] . $piece['type'])
			{
				// if there is a piece left to be moved
				if (0 < $this->board[$sector][$key]['num'])
				{
					// if we only care about non-moved pieces
					if ($unmoved)
					{
						// if there's one that hasn't been moved yet
						if ($piece['num'] > $piece['moved'])
						{
							// subtract one from the count
							if ($this->debug) call('--UNMOVED PIECE FOUND--');
							--$this->board[$sector][$key]['num'];
						}
					}
					else // moved doesn't matter
					{
						// subtract one from the count
						if ($this->debug) call('--MOVED (OR DON\'T CARE) PIECE FOUND--');
						--$this->board[$sector][$key]['num'];

						// if moved is not yet zero
						if (0 < $this->board[$sector][$key]['moved'])
						{
							// subtract one from the moved count
							--$this->board[$sector][$key]['moved'];
						}
					}
				} // end of if enough to move check
			} // end of if found check
		} // end search foreach loop
		if ($this->debug) call($this->board[$sector]);

		if ($this->debug) echo '</div>';
	} // end removePiece



	function placePiece($piece_code, $sector, $moved = true)
	{
		if ($this->debug) echo "<br/>placePiece($piece_code, $sector, $moved)<div style=\"border:1px dotted green;margin: 0 5px 0 2em;\">";

		// get the sector's contents
		$contents = $this->board[$sector];
		if ((0 == count((array) $contents)) || (false == $contents))
		{
			$contents = array( );
		}
		if ($this->debug) call($contents);

		// parse through that array and break it in separate piece types
		$not_found = true;
		foreach ($contents as $key => $piece)
		{
			// if we found it
			if ($piece_code == $piece['color'] . $piece['type'])
			{
				// add one to the count
				++$contents[$key]['num'];
				if ($this->debug) call('--PIECE ADDED--');

				// if we need to add one to the moved count
				if ($moved)
				{
					++$contents[$key]['moved'];
					if ($this->debug) call('--MOVE ADDED--');
				}

				// set the error var
				$not_found = false;
			}
		}

		// add the piece if we need to
		if ($not_found)
		{
			// get the piece data
			$piece = $this->getPieceData($piece_code);
			if ($this->debug) call($piece);

			$contents[] = array(
				'num' => 1,
				'color' => strtoupper($piece['color']),
				'type' => strtoupper($piece['type']),
				'owner' => $this->players[$piece['color']],
				'power' => $this->PIECE[$piece['type']]['power'],
				'moves' => $this->PIECE[$piece['type']]['max_sectors'],
				'moved' => ($moved ? 1 : 0)
			);
			if ($this->debug) call('--NEW PIECE PLACED--');
			if ($this->debug && $moved) call('--MOVE ADDED--');
		}
		if ($this->debug) call($contents);

		// save it to the board
		$this->board[$sector] = $contents;

		if ($this->debug) echo '</div>';
	} // end placePiece



	function movePiece($piece_code, $from_sector, $to_sector)
	{
		// if we are moving a piece, we cannot move it again
		$moved = true;

		$this->removePiece($piece_code, $from_sector, $moved);
		$this->placePiece($piece_code, $to_sector, $moved);
	} // end movePiece



	function tradePieces($sector, $from_pieces, $to_piece)
	{
		// when trading pieces, it doesn't matter if the piece
		// had already been moved prior to the trade
		$moved = false;

		// if there are many pieces to trade (Megamissle)
		if (is_array($from_pieces))
		{
			foreach ($from_pieces as $piece)
			{
				$piece = $this->getPieceData($piece);

				for ($i = 0; $i < $piece['num']; ++$i)
				{
					$this->removePiece($piece['color'] . $piece['type'], $sector, $moved);
				}
			}
		}
		else // there is only one type of piece to trade
		{
			$this->removePiece($from_pieces, $sector, $moved);
		}

		// when trading pieces, the new piece is considered 'unmoved'
		// so it may be moved later in the same command set
		$this->placePiece($to_piece, $sector, $moved);
	} // end tradePieces



	//*/
	//////////////////////////////////////////////////////////
	//
	//   Board Functions
	//
	//////////////////////////////////////////////////////////
	//*



	/**
	 * setFoldedBoard
	 * sets the object board var with the
	 * expanded version of the folded board
	 * given
	 *
	 *@access public
	 *
	 *@param string
	 *
	 *@return void
	 */
	function setFoldedBoard($fld_board)
	{
		$this->board = $this->_expandBoard($fld_board);
	}



	/**
	 * setExpandedBoard
	 * sets the object board var with the
	 * expanded version given
	 *
	 *@access public
	 *
	 *@param array
	 *
	 *@return void
	 */
	function setExpandedBoard($exp_board)
	{
		$this->board = $exp_board;
	}



	/**
	 * _expandBoard
	 * expands the folded board given
	 * and returns the expanded board
	 *
	 *@access private
	 *
	 *@param string
	 *
	 *@return array
	 */
	function _expandBoard($fld_board)
	{
		$exp_board = explode('/', strtoupper($fld_board));
		$exp_board = array_combine($this->SECTORS, $exp_board);

		// now run through each sector and parse out each piece array
		foreach ($exp_board as $sector => $contents)
		{
			if ('' == $contents)
			{
				continue;
			}

			$pieces = explode(',', $contents);

			// remove the contents from the board
			$exp_board[$sector] = null;

			$new = array( );
			foreach ($pieces as $piece)
			{
#       call($piece);

				// get the number of the pieces
				if (preg_match('/\\d+/i', $piece, $match))
				{
					$new['num'] = (int) $match[0];
				}
				else
				{
					$new['num'] = 1;
				}
#       call($new);

				// get the color of the pieces
				if (preg_match('/[YKRA]/i', $piece, $match))
				{
					$new['color'] = $match[0];
				}
				else
				{
					$this->error = 'No color code found';
					return false;
				}
#       call($new);

				// get the type of the pieces
				if (preg_match('/[IGTHFBDCPMV]/i', $piece, $match))
				{
					$new['type'] = $match[0];
				}
				else
				{
					$this->error = 'No piece code found';
					return false;
				}
#       call($new);

				// get the owner of the pieces
				if (null != $this->players[$new['color']])
				{
					$new['owner'] = $this->players[$new['color']];
				}
				else
				{
					$this->error = 'No owner for this color';
					return false;
				}
#       call($new);

				// get the value of the piece
				if (isset($this->PIECE[$new['type']]['power']))
				{
					$new['power'] = (int) $this->PIECE[$new['type']]['power'];
				}
				else
				{
					$new['power'] = 0;
				}
#       call($new);

				// add the moves and moved values
				$new['moves'] = (int) $this->PIECE[$new['type']]['max_sectors'];
				$new['moved'] = 0;

				// save the new array into the sector
				$exp_board[$sector][] = $new;
			} // end of the foreach pieces loop
		} // end of the foreach sector loop

		return $exp_board;
	} // end _expandBoard



	/**
	 * _foldBoard
	 * folds the expanded board given and
	 * returns the folded board
	 *
	 *@access private
	 *
	 *@param array
	 *
	 *@return string
	 */
	function _foldBoard($exp_board)
	{
		// parse through each sector and fold it up
		foreach ($exp_board as $sector => $contents)
		{
			if ('' == $contents)
			{
				continue;
			}

			// remove the contents from the board
			$exp_board[$sector] = '';

#     call( );
			// parse through each piece and fold it up
			$new_contents = array( );
			foreach ($contents as $piece)
			{
				$new = '';
#       call($piece);

				if (0 >= $piece['num'])
				{
#         call('skipped');
					continue;
				}
				else if (1 == $piece['num'])
				{
					$new .= $piece['color'] . $piece['type'];
				}
				else // there is more than one
				{
					$new .= $piece['num'] . $piece['color'] . $piece['type'];
				}
#       call($new);

				$new_contents[] = $new;
#       call($new_contents);
			} // end of foreach contents loop

			// insert the contents into the sector
			$exp_board[$sector] = implode(',', $new_contents);
		} // end of foreach sector loop

		$fld_board = implode('/', $exp_board);
		return strtoupper($fld_board);
	} // end _foldBoard




	/**
	 * getExpandedBoard
	 * returns the expanded version of the
	 * current board
	 *
	 *@access public
	 *
	 *@param void
	 *
	 *@return array
	 */
	function getExpandedBoard( )
	{
		return $this->board;
	}



	/**
	 * getFoldedBoard
	 * returns the folded version of the
	 * current board
	 *
	 *@access public
	 *
	 *@param void
	 *
	 *@return string
	 */
	function getFoldedBoard( )
	{
		return $this->_foldBoard($this->board);
	}



	/**
	 * clearBoard
	 * clears the object board by replacing
	 * it with an empty board complete with keys
	 *
	 *@access public
	 *
	 *@param void
	 *
	 *@return void
	 */
	function clearBoard( )
	{
		$this->board = array_keys($this->SECTORS);
	}



	/**
	 * cleanBoard
	 * removes any zero count pieces from the
	 * object board by folding it, then expanding it
	 *
	 *@access public
	 *
	 *@param void
	 *
	 *@return void
	 */
	function cleanBoard( )
	{
		$board = $this->_foldBoard($this->board);
		$this->board = $this->_expandBoard($board);
	}



	/**
	 * simplifyBoard
	 * simplifies the board by removing empty sectors
	 * and empty piece arrays
	 *
	 *@access public
	 *
	 *@param void
	 *
	 *@return array
	 */
	function simplifyBoard( )
	{
		$board = $this->board;
		foreach ($board as $sector => $contents)
		{
			// if there is nothing in this sector
			if (false == $contents)
			{
				// remove it from the array
				unset($board[$sector]);
			}
			else // there is something in this sector
			{
				// look for zero count pieces
				foreach ($contents as $key => $piece)
				{
					// if there are no pieces
					if (0 >= $piece['num'])
					{
						// remove it from the array
						unset($board[$sector][$key]);
					}
				}
			}
		} // end of foreach board loop

		return $board;
	} // end simplifyBoard



	//*/
	//////////////////////////////////////////////////////////
	//
	//   Gameplay Functions
	//
	//////////////////////////////////////////////////////////
	//*



	function setPlayers($players)
	{
		$this->players = $players;
	}



	function addPlayer($color, $player_id)
	{
		$this->players[$color] = $player_id;
	}



	function removePlayer($color)
	{
		$this->players[$color] = 0;
	}



	function doMegaKills( )
	{
		// get a simplified board
		$board = $this->simplifyBoard( );

		// search through the
		foreach ($board as $sector => $contents)
		{
			foreach ($contents as $piece)
			{
				if (('M' == $piece['type']) && (0 < $piece['moved']))
				{
					// if we are in a headquarters
					if (false !== strpos($sector, 'Q'))
					{
						// get the color of the headquarters
						$color = substr($sector, 0, 1);

						// if this color is still alive
						if ($this->isAlive($color))
						{
							// destroy the whole sector
							$this->board[$sector] = '';

							// replace the flag
							$this->placePiece($color . 'Q', $color . 'V', false);
						}
						else // this color is not still alive
						{
							// destroy the whole sector
							$this->board[$sector] = '';
						}
					}
					else // we are not in a headquarters
					{
						// destroy the whole sector
						$this->board[$sector] = '';
					}
				} // end if moved mega check
			} // end foreach piece loop
		} // end foreach sector loop
	} // end doMegaKills



	function clearConflicts( )
	{
		$this->conflicts = false;
	}



	function getConflicts( )
	{
		// get a simplified board
		$board = $this->simplifyBoard( );

		// init the bounce flag
		$has_bounce = false;

		// parse through the board and search for conflicts
		$conflicts = array( ); // init a blank array
		foreach ($board as $sector => $contents)
		{
			// get the players who are occupying this sector
			$occupants = array( ); // init the array
			foreach ($contents as $piece)
			{
				// if we already have an entry for this player
				if (isset($occupants[$piece['owner']]))
				{
					// if we already have an entry for this color
					if (isset($occupants[$piece['owner']][$piece['color']]))
					{
						// add to it
						$occupants[$piece['owner']][$piece['color']] += ($piece['num'] * $piece['power']);

						// add to the total as well
						$occupants[$piece['owner']]['total'] += ($piece['num'] * $piece['power']);
					}
					else // we don't have an entry for this color yet
					{
						// create one
						$occupants[$piece['owner']][$piece['color']] = ($piece['num'] * $piece['power']);

						// add to the total as well
						$occupants[$piece['owner']]['total'] += ($piece['num'] * $piece['power']);
					}
				}
				else // we have no entry for this player yet
				{
					// create one
					$occupants[$piece['owner']][$piece['color']] = ($piece['num'] * $piece['power']);

					// create the total as well
					$occupants[$piece['owner']]['total'] = ($piece['num'] * $piece['power']);
				}
			} // end of foreach contents loop

			// now that we have the players found, look for conflicts
			$bounced = $stayed = $winner = $losers = false; // init the vars
			if (1 < count($occupants))
			{
				$max = 0; // look for a winner
				foreach ($occupants as $stats)
				{
					// set a new max if we need to
					$max = ($stats['total'] > $max) ? $stats['total'] : $max;
				}

				// now that we know what the highest power is
				// find out who got bounced
				$num_high = 0;
				foreach ($occupants as $stats)
				{
					// find out how many high scores there were
					$num_high += ($stats['total'] == $max) ? 1 : 0;
				}

				// now that we know how many high scores there were
				// find out who they belong to
				if (1 < $num_high)
				{
					foreach ($occupants as $player => $stats)
					{
						if ($stats['total'] == $max)
						{
							$has_bounce = true;
							$bounced[] = $player;
						}
					}

					// if there are four players in here
					// the lower players may get bounced as well
					if (4 == count($occupants))
					{
						$low_max = 0; // look for a winner
						foreach ($occupants as $player => $stats)
						{
							if ( ! in_array($player, $bounced))
							{
								// set a new low max if we need to
								$low_max = ($stats['total'] > $low_max) ? $stats['total'] : $low_max;
							}
						}

						// now that we know what the highest low power is
						// find out who got bounced
						$num_low = 0;
						foreach ($occupants as $player => $stats)
						{
							if ( ! in_array($player, $bounced))
							{
								// find out how many high lower scores there were
								$num_low += ($stats['total'] == $low_max) ? 1 : 0;
							}
						}

						// now that we know how many high lower scores there were
						// find out who they belong to
						if (1 < $num_low)
						{
							foreach ($occupants as $player => $stats)
							{
								// if we are here, everybody got bounced
								$bounced[] = $player;
							}

							$bounced = array_unique($bounced);
						}
					} // end of four player bounce if
				} // end of bounce if

				// figure out who stayed
				// make sure we have an array to test
				$bounced_test = (is_array($bounced)) ? $bounced : array( );
				foreach ($occupants as $player => $stats)
				{
					// if they weren't bounced
					if ( ! in_array($player, $bounced_test))
					{
						// they must have stayed
						$stayed[] = $player;
					}
				}

				// if some did stay
				if (false !== $stayed)
				{
					// we have more looking to do
					// find the new max
					$max = 0; // look for a winner
					foreach ($occupants as $player => $stats)
					{
						if (in_array($player, $stayed))
						{
							// set a new max
							$max = ($stats['total'] > $max) ? $stats['total'] : $max;
						}
					}

					// find the winners and losers
					foreach ($occupants as $player => $stats)
					{
						// if the player stayed
						if (in_array($player, $stayed))
						{
							// and their points match the max
							if ($stats['total'] == $max)
							{
								// there is only one winner
								$winner = $player;
							}
							else // their points don't match the max
							{
								// add them to the losers array
								$losers[] = $player;
							}
						}
					} // end of winner foreach loop
				} // end of false bounced if

				// save all info to the conflicts array as strings (or false)
				$conflicts[$sector] = $occupants;
				$conflicts[$sector]['bounced'] = (is_array($bounced)) ? implode(',', $bounced) : false;
				$conflicts[$sector]['stayed']  = (is_array($stayed))  ? implode(',', $stayed)  : false;
				$conflicts[$sector]['losers']  = (is_array($losers))  ? implode(',', $losers)  : false;
				$conflicts[$sector]['winner']  = $winner;
			} // end of conflict if
		} // end foreach sector loop

		// now save the conflicts array to the object
		$this->conflicts = $conflicts;
		if ($this->debug) call($conflicts);

		// and return the bounce flag to the script
		return $has_bounce;
	} // end getConflicts



	function doBounce( )
	{
		if ($this->debug) echo "<br/>doBounce( )<div style=\"border:2px solid #A0A;margin: 0 5px 0 2em;\">";

		// parse through the conflict array and find the bounces
		foreach ($this->conflicts as $sector => $conflict)
		{
			// if this conflict has a bounce
			if (false !== $conflict['bounced'])
			{
				if ($this->debug) { call($sector); call($this->board[$sector]); call($conflict); call($this->commands); }
				// find the colors for the players involved
				$bounced_players = explode(',', $conflict['bounced']);
				foreach ($bounced_players as $player)
				{
					$players[$player] = array_keys($this->players, $player);
				}
				if ($this->debug) { call($bounced_players); call($players); }

				// parse through each bounced player's colors
				foreach ($players as $player => $colors)
				{
					// parse through each color
					foreach ($colors as $color)
					{
						if ($this->debug) { call('--NEW COLOR--'); call($color); }
						// parse through the commands and undo any trades that were done IN this sector
						foreach ($this->commands[$color] as $command)
						{
							if ($this->debug) call($command);
							// if we found one
							if (('trade' == $command['type']) && ($sector == $command['sector']))
							{
								if ($this->debug) call('--UNTRADING PIECE--');
								// remove the traded piece
								$this->removePiece($command['to'], $sector, false); // we don't care if it was moved

								// parse through the from pieces and place them all
								foreach ($command['from'] as $piece)
								{
									// get the piece data
									$data = $this->getPieceData($piece);
									if ($this->debug) { call($piece); call($data); }

									// replace all the pieces
									for ($i = 0; $i < $data['num']; ++$i)
									{
										$this->placePiece($data['color'] . $data['type'], $command['sector'], false); // if it was moved here, it wasn't moved there
									}
								} // end foreach from piece loop
							} // end if traded here found check
						} // end foreach command loop

						// parse through the commands and bounced any moves that were made to this sector
						foreach ($this->commands[$color] as $command)
						{
							if ($this->debug) call($command);
							// if we found one
							if (('move' == $command['type']) && ($sector == $command['to']))
							{
								if ($this->debug) call('--BOUNCING PIECE--');
								// move it back
								$this->removePiece($command['piece'], $command['to'], false); // move the moved ones
								$this->placePiece($command['piece'], $command['from'], false); // put it back as not moved
							} // end if move here found check
						} // end foreach command loop
					} // end foreach color loop
				} // end foreach colors loop
			} // end if bounced conflict check
		} // end foreach conflict loop

		echo '</div>';
	} // end doBounce



	function resolveConflicts( )
	{
		if ($this->debug) echo "<br/>resolveConflicts( )<div style=\"border:2px solid #0A0;margin: 0 5px 0 2em;\">";

		// parse through the conflicts array and award pieces
		foreach ($this->conflicts as $sector => $conflict)
		{
			if ($this->debug) { call($sector); call($conflict); }

			// if there are no players left, skip it
			if ('' == $conflict['stayed'])
			{
				if ($this->debug) call('--NO PIECES REMAIN--');
				continue;
			}

			// now award the pieces to the winner
			// first find out how many colors the winner has in this sector
			$winner = $conflict['winner'];
			if ($this->debug) echo 'winner = ' . $winner;
			$win_color = $prev_points = false;

			// parse through each and compare
			foreach($conflict[$winner] as $color_code => $points)
			{
				// if it's not the total
				if ('total' != $color_code)
				{
					// if we haven't seen a color points yet, or this one is larger
					if (false === $win_color || $prev_points < $points)
					{
						$win_color = $color_code;
						$prev_points = $points;
					}
					else if ($prev_points == $points) // we have a tie
					{
						// make the winner choose a color
						$this->awards[$sector] = $winner;
					}
				} // end if not total
			} // end foreach entry loop
			if ($this->debug) call($win_color);

			// if we only have one color
			if ( ! isset($this->awards[$sector]))
			{
				if ($this->debug) call('--ONLY ONE WINNER COLOR--');
				// parse through the pieces in this sector
				foreach ($this->board[$sector] as $piece)
				{
					if ($this->debug) call($piece);
					// if it's somebody else's piece (and not the flag)
					if (($piece['owner'] != $winner) && ('V' != $piece['type']))
					{
						if ($this->debug) call('--NOT WINNER--');
						// give them to the winner (put in reserve)
						for ($i = 0; $i < $piece['num']; ++$i)
						{
							$this->removePiece($piece['color'] . $piece['type'], $sector, false);
							$this->placePiece($win_color . $piece['type'], $win_color . 'U', false);
						}
					} // end if not winner
				} // end foreach pieces
			} // end if only one color
		} // end foreach conflicts loop

		if ($this->debug) echo '</div>';
	} // end resolveConflicts



	function clearFlagCaptures( )
	{
		$this->flagCaptures = false;
		$this->miniFlag = false;
	}



	function getFlagCaptures( )
	{
		if ($this->debug) echo "<br/>getFlagCaptures( )<div style=\"border:2px solid #00A;margin: 0 5px 0 2em;\">";

		$captures = $mini = false;
		$colors   = array_keys($this->players);

		foreach ($colors as $color)
		{
			if (is_array($this->board[$color . 'Q']))
			{
				$occupants = false;

				foreach ($this->board[$color . 'Q'] as $piece)
				{
					if ($piece['owner'] != $this->players[$color])
					{
						// if we already have an entry for this player
						if (isset($occupants[$piece['owner']]))
						{
							// if we already have an entry for this color
							if (isset($occupants[$piece['owner']][$piece['color']]))
							{
								// add to it
								$occupants[$piece['owner']][$piece['color']]['total'] += ($piece['num'] * $piece['power']);

								// if the piece is a grunt, let us know
								if (preg_match('/[IG]/i', $piece['type']))
								{
									$occupants[$piece['owner']][$piece['color']]['infantry'] = true;
								}
							}
							else // we don't have an entry for this color yet
							{
								// create one
								$occupants[$piece['owner']][$piece['color']]['total'] = ($piece['num'] * $piece['power']);

								// if the piece is a grunt, let us know
								if (preg_match('/[IG]/i', $piece['type']))
								{
									$occupants[$piece['owner']][$piece['color']]['infantry'] = true;
								}
							}
						}
						else // we have no entry for this player yet
						{
							// create one
							$occupants[$piece['owner']][$piece['color']]['total'] = ($piece['num'] * $piece['power']);

							// if the piece is a grunt, let us know
							if (preg_match('/[IG]/i', $piece['type']))
							{
								$occupants[$piece['owner']][$piece['color']]['infantry'] = true;
								$mini[$color][] = $piece['color'];
							}
							else // the piece is not a grunt, set a default value
							{
								$occupants[$piece['owner']][$piece['color']]['infantry'] = false;
							}
						}
					} // end if not native piece check
				} // end foreach piece loop
				if ($this->debug) call($occupants);

				// loop through the newly created array
				// and remove the values if there is no grunt
				if (is_array($occupants))
				{
					if (is_array(reset($occupants)))
					{
						$values = reset(reset($occupants));
						if ($this->debug) call($values);

						if (false === $values['infantry'])
						{
							$occupants = false;
						}
					}
				}

				if ($this->debug) call($occupants);

				// if we have occupants of this sector
				if (false !== $occupants)
				{
					$captures[$color] = $occupants;
				}
			} // end if contents check
		} // end foreach color loop
		if ($this->debug) { call($captures); call($mini); }

		// save it in the object var
		$this->flagCaptures = $captures;
		$this->miniFlag = $mini;
		if ($this->debug) echo '</div>';
	} // end getFlagCaptures



	function resolveFlagCaptures($given_color = false)
	{
		if ($this->debug) echo "<br/>resolveFlagCaptures($given_color)<div style=\"border:2px solid #AA0;margin: 0 5px 0 2em;\">";

		// make sure we have data to deal with
		if (false === $this->flagCaptures)
		{
			if ($this->debug) { call(false); echo '</div>'; }
			return false;
		}

		// test for simultaneous flag captures
		// TODO: this sucks, find a better way
		if (false !== $this->miniFlag)
		{
			$captees = array_keys($this->miniFlag);
			foreach ($this->miniFlag as $captee => $capteurs)
			{
				foreach ($capteurs as $capteur)
				{
					call($captees);
					call($capteur);

					if (array($captee) == $this->miniFlag[$capteur])
					{
						call('--POSSIBLE SIMUL-CAPTURE--');
						call($this->miniFlag);
						call($captees);
						call($capteur);
					}
				}
			}
		}

		// get a simplified board
		$board = $this->simplifyBoard( );

		// parse through each capture
		$losers = array( );
		foreach ($this->flagCaptures as $loser_color => $winner)
		{
			if ($this->debug) { echo '<hr />'; call($loser_color); call($winner); }

			// find out who to give the winnings to
			if ((false !== $given_color) && isset($given_color[$loser_color]))
			{
				$win_color = $given_color[$loser_color];
			}
			else // there was no given color
			{
				$max = $win_color = 0;
				foreach ($winner as $id => $colors)
				{
					foreach ($colors as $color => $data)
					{
						// if there was a grunt, and the total is higher than previous
						if ((false !== $data['infantry']) && ($max < $data['total']))
						{
							$max = $data['total'];
							$win_color = $color;
						}
						else if ((false !== $data['infantry']) && ($max == $data['total']))
						{
							$this->awards[$loser_color . 'Q'] = $id . 'V';
							continue 3; // skip to next flag capture
						}
					} // end foreach color loop
				} // end foreach winner loop (should only be one)
			} // end given color check
			if ($this->debug) call($win_color);

			// check for a win color, if none, there must have been no grunts
			if (0 === $win_color)
			{
				if ($this->debug) call('--CONTINUED TO NEXT FLAG CAPTURE--');
				continue; // skip to next flag capture
			}

			// add this loser to the array
			$losers[] = $loser_color;

			// parse through each occupied sector
			foreach ($board as $sector => $contents)
			{
				if ($this->debug) { call($sector); call($contents); }
				// parse through each piece
				foreach ($contents as $piece)
				{
					// if the piece is loser colored
					if ($piece['color'] == $loser_color)
					{
						if ($this->debug) call("--{$piece['color']}{$piece['type']} FOUND AT {$sector}--");
						$this->removePiece($piece['color'] . $piece['type'], $sector, false);

						// if the piece is the flag, don't place it
						if ('V' != $piece['type'])
						{
							$this->placePiece($win_color . $piece['type'], $win_color . 'U', false);
						}
					} // end if loser's piece check
				} // end foreach piece loop
			} // end foreach sector loop
		} // end foreach capture loop

		// return the losers array
		if ($this->debug) { call($losers); echo '</div>'; }
		return $losers;
	} // end resolveFlagCaptures



	function getIncapacitated( )
	{
		// init the arrays
		$alive = $found = array( );

		// it's basically searching the board for players
		// with a flag but no other pieces, or not enough
		// power units to make a piece

		// find all the players with flags
		// parse through each color
		foreach (array_keys($this->players) as $color)
		{
			// check if this color is alive
			if ($this->isAlive($color))
			{
				// set this color as 'alive'
				$alive[] = $color;
			} // end if alive check
		} // end foreach color loop


		// find all the players with pieces
		// parse through each sector
		foreach ($this->board as $contents)
		{
			// if there are pieces here
			if (is_array($contents))
			{
				// parse through the pieces
				foreach ($contents as $piece)
				{
					 // if it's not a flag      and        has not been found yet    -- AND --    it's not a point   and at least one of them  OR     it is a point       and   at least two of them
					if ((('V' != $piece['type']) && ! in_array($piece['color'], $found)) && ((('P' != $piece['type']) && (1 <= $piece['num'])) || (('P' == $piece['type']) && (2 <= $piece['num']))))
					{
						$found[] = $piece['color'];
					}
				} // end foreach piece loop
			} // end if contents
		} // end foreach sector loop

		// return the incapacitated colors (alive, but not found)
		return array_diff($alive, $found);
	} // end getIncapacitated



	function awardPoints( )
	{
		if ($this->debug) echo "<br/>awardPoints( )<div style=\"border:1px solid #555;margin: 0 5px 0 2em;\">";

		$awarded = array( );
		$colors  = array_keys($this->players);

		// parse through each color
		foreach($colors as $color)
		{
			if ($this->debug) { call($color); call($this->isAlive($color)); }
			// make sure this country is alive
			if ($this->isAlive($color))
			{
				// search each of the country sectors
				for ($i = 0; $i < 9; ++$i)
				{
					if (is_array($this->board[$color . $i]))
					{
						foreach ($this->board[$color . $i] as $piece)
						{
							// if the piece is not the country color _and_ has pieces there AND this color hasn't been found yet _or_ this color hasn't been found in this country yet
							if ((($piece['color'] != $color) && (0 < $piece['num'])) && ( ! isset($awarded[$piece['color']]) || ! in_array($color, $awarded[$piece['color']])))
							{
								if ($this->debug) call("--{$piece['color']} PIECE FOUND AT {$color}{$i}--");
								$awarded[$piece['color']][] = $color;
							}
						} // end foreach piece loop
					} // end contents check
				} // end for each country sector loop
			} // end if alive check
		} // end foreach color loop
		call($awarded);

		// count each and award points
		foreach ($awarded as $color => $number)
		{
			for ($i = 0; $i < count($number); ++$i)
			{
				$this->placePiece($color . 'P', $color . 'U', false);
			}
		}

		if ($this->debug) echo '</div>';
	} // end awardPoints



	function isAlive($color)
	{
		// search the color's headquarters for a flag
		if (is_array($this->board[$color . 'Q']))
		{
			foreach ($this->board[$color . 'Q'] as $piece)
			{
				// if we found a flag
				if ('V' == $piece['type'])
				{
					return true;
				}
			}
		}

		// if we get here, the color is dead (or never existed)
		return false;
	}



	function getAwards( )
	{
		return $this->awards;
	}



	function clearAwards( )
	{
		$this->awards = array( );
	}



	//*/
	//////////////////////////////////////////////////////////
	//
	//   Other Functions
	//
	//////////////////////////////////////////////////////////
	//*



	/**
	 * setError
	 * sets the object error var
	 *
	 *@access public
	 *
	 *@param string
	 *
	 *@return void
	 */
	function setError($error)
	{
		$this->error = $error;
	}



	/**
	 * getError
	 * retrieves the object error var
	 *
	 *@access public
	 *
	 *@param void
	 *
	 *@return string
	 */ function getError( )
	{
		return $this->error;
	}



	/**
	 * clearError
	 * clears the object error var
	 *
	 *@access public
	 *
	 *@param void
	 *
	 *@return void
	 */ function clearError( )
	{
		$this->error = false;
	}

} // end of class

?>